<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Painel PMO — Gestão de Capacidade (Folha)</title>

  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a30;
      --text:#e8efff;
      --muted:#93a4c7;
      --line:rgba(255,255,255,.10);

      --do:#60a5fa;
      --ge:#34d399;
      --jc:#fbbf24;
      --al:#fb7185;

      --danger:#ef4444;
      --ok:#22c55e;

      --rowH:18px;
      --headH1:14px;
      --headH2:14px;

      --wClient:170px;
      --wTurno:86px;
      --wDate:64px;

      --solidBG:#0b1220;
      --solidHdr:#0a162e;
      --solidSticky:#0b1220;

      --mStrip:#2b2a57;
      --tStrip:#0f3348;

      --weekend:#2a2618;

      --freeCell:#133322;
      --freeHdr:#17462c;

      --confHdr:#3a1212;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      background:radial-gradient(900px 500px at 20% 0%, #14264a 0%, var(--bg) 60%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
    }

    /* ================= TOP (FILTROS) ================= */
    .top{
      background:linear-gradient(180deg, rgba(10,22,46,.98), rgba(10,22,46,.86));
      border-bottom:1px solid var(--line);
      padding:10px 12px 10px;
    }
    .topRow1{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      margin-bottom:10px;
    }
    .titleBlock{
      min-width:0;
    }
    .title{
      font-weight:950; font-size:16px; line-height:1.1;
    }
    .subtitle{
      color:var(--muted); font-size:12px; font-weight:750; margin-top:4px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .topActions{
      display:flex; gap:10px; align-items:center;
    }
    .btn{
      border:1px solid rgba(255,255,255,.45);
      background:transparent;
      color:#fff;
      padding:10px 14px;
      border-radius:999px;
      font-weight:900;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .btnSoft{
      border:1px solid var(--line);
      background:#0f1a30;
      color:#fff;
    }

    .filters{
      display:grid;
      grid-template-columns: 1.4fr 1fr 0.7fr 0.7fr auto;
      gap:10px;
      align-items:end;
    }
    .field label{
      display:block; font-size:11px; color:var(--muted); font-weight:850;
      margin:0 0 6px;
    }
    .field input,.field select{
      width:100%;
      background:#0f1a30;
      border:1px solid var(--line);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:850;
      outline:none;
    }

    .chipRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:10px;
    }

    .chipBtn{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background:#0f1a30;
      cursor:pointer;
      user-select:none;
      font-weight:950;
      font-size:12px;
      color:#fff;
    }
    .chipBtn:active{ transform:scale(.99); }
    .chipBtn .dot{ width:10px;height:10px;border-radius:50%; }
    .chipBtn[aria-pressed="true"]{
      background:#14264a;
      border-color: rgba(255,255,255,.55);
    }

    .modeBtns{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-left:8px;
    }
    .modeBtn{
      display:inline-flex;
      align-items:center;
      padding:8px 14px;
      border-radius:999px;
      border:1px solid var(--line);
      background:#0f1a30;
      cursor:pointer;
      user-select:none;
      font-size:12px;
      font-weight:950;
      color:#fbbf24; /* amarelo */
    }
    .modeBtn[aria-pressed="true"]{
      background:#14264a;
      border-color: rgba(255,255,255,.45);
    }

    .kpis{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap:10px;
      margin-top:10px;
    }
    .kpi{
      background:#0f1a30;
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
    }
    .kpi .k{ color:var(--muted); font-size:11px; font-weight:850; }
    .kpi .v{ font-size:18px; font-weight:950; margin-top:6px; }

    /* colapsar filtros */
    .collapsed .filters,
    .collapsed .chipRow,
    .collapsed .kpis{
      display:none !important;
    }
    .collapsed{
      padding-bottom:8px;
    }

    /* ================= GRID ================= */
    .gridWrap{
      height: calc(100vh - 250px);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .gridCard{
      flex:1 1 auto;
      min-height:0;
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background:var(--panel);
      display:flex;
      flex-direction:column;
    }
    .gridTitle{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      font-weight:950;
      background: var(--solidBG);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
    }
    .status{
      color:var(--muted);
      font-size:12px;
      font-weight:850;
      white-space:nowrap;
    }

    /* viewport vertical do grid (sem barra horizontal) */
    .tableY{
      flex:1 1 auto;
      min-height:0;
      overflow-y:auto;
      overflow-x:hidden;
      background:var(--solidBG);
      overscroll-behavior: contain;
    }

    /* barra horizontal sempre visível (espelho) */
    .xBar{
      height:16px;
      overflow-x:auto;
      overflow-y:hidden;
      background: var(--solidBG);
      border-top:1px solid rgba(255,255,255,.06);
    }
    .xBarInner{
      height:1px; /* só para criar largura */
    }

    /* wrapper do grid de datas (scroll horizontal real) */
    .xPane{
      overflow-x:auto;
      overflow-y:hidden;
      background:var(--solidBG);
    }

    table{
      border-collapse:separate;
      border-spacing:0;
      table-layout:fixed;
      width:max-content;
      min-width:100%;
    }

    thead tr{ height: var(--headH1); }
    thead tr:nth-child(2){ height: var(--headH2); }
    tbody tr{ height: var(--rowH); }

    thead th{
      position: sticky;
      background: var(--solidHdr);
      color: var(--muted);
      border-bottom:1px solid rgba(255,255,255,.16);
      border-right:1px solid rgba(255,255,255,.06);
      text-align:center;
      padding:0 6px;
      white-space:nowrap;
      font-size:10px;
      font-weight:950;
      z-index: 10;
    }
    thead tr:nth-child(1) th{
      top: 0;
      height: var(--headH1);
      line-height: var(--headH1);
      z-index: 20;
    }
    thead tr:nth-child(2) th{
      top: var(--headH1);
      height: var(--headH2);
      line-height: var(--headH2);
      z-index: 19;
    }

    /* header Cliente/Turno 4-way sticky */
    thead th.thClient{
      left:0;
      width:var(--wClient);
      min-width:var(--wClient);
      max-width:var(--wClient);
      text-align:left;
      padding-left:10px;
      z-index:1000;
      background: var(--solidHdr);
      border-right:1px solid rgba(255,255,255,.14);
    }
    thead th.thTurno{
      left:var(--wClient);
      width:var(--wTurno);
      min-width:var(--wTurno);
      max-width:var(--wTurno);
      z-index:999;
      background: var(--solidHdr);
      border-right:1px solid rgba(255,255,255,.14);
    }

    tbody td{
      height:var(--rowH);
      line-height:var(--rowH);
      font-size:11px;
      border-bottom:1px solid rgba(255,255,255,.06);
      border-right:1px solid rgba(255,255,255,.04);
      padding:0 4px;
      white-space:nowrap;
      background:var(--solidBG);
      vertical-align:middle;
    }

    /* sticky body cols */
    tbody td.tdClient{
      position:sticky;
      left:0;
      width:var(--wClient);
      min-width:var(--wClient);
      max-width:var(--wClient);
      z-index:50;
      background: var(--solidSticky) !important;
      border-right:1px solid rgba(255,255,255,.14);
    }
    tbody td.tdTurno{
      position:sticky;
      left:var(--wClient);
      width:var(--wTurno);
      min-width:var(--wTurno);
      max-width:var(--wTurno);
      z-index:49;
      background: var(--solidSticky) !important;
      border-right:1px solid rgba(255,255,255,.14);
      text-align:center;
      font-weight:950;
    }

    .clientCell{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      padding:0 6px;
      height:100%;
      font-weight:950;
      text-transform:uppercase;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    /* faixas manhã/tarde */
    tr.rowM td{ background: linear-gradient(90deg, var(--mStrip), var(--solidBG)); }
    tr.rowT td{ background: linear-gradient(90deg, var(--tStrip), var(--solidBG)); }
    tr.rowM td.tdClient, tr.rowM td.tdTurno,
    tr.rowT td.tdClient, tr.rowT td.tdTurno{
      background: var(--solidSticky) !important;
    }

    /* weekend */
    .weekend{ background: var(--weekend) !important; }

    /* hidden column */
    .colHidden{ display:none; }

    /* idle highlight */
    .freeHdr{ background: var(--freeHdr) !important; color:#d1fae5 !important; }
    .freeCell{ background: var(--freeCell) !important; }

    /* conflict highlight */
    .confHdr{ background: var(--confHdr) !important; color:#fee2e2 !important; }

    /* chips */
    .cellChips{display:flex; align-items:center; justify-content:center; gap:2px;}
    .chip{
      display:inline-flex; align-items:center; justify-content:center;
      min-width:22px; height:14px; padding:0 5px;
      border-radius:5px;
      border:1px solid rgba(255,255,255,.10);
      background:#14264a;
      font-weight:950;
      font-size:10px;
      line-height:14px;
      color:var(--text);
    }
    .chip.empty{opacity:.25}
    .chip.conflict{
      background: var(--danger) !important;
      color:#0b1220 !important;
      border-color: rgba(0,0,0,.18);
    }

    /* ================= PANELS (exceções) ================= */
    .panels{
      border:1px solid var(--line);
      border-radius:14px;
      background:var(--panel);
      overflow:hidden;
    }
    .panelsHeader{
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background: var(--solidBG);
      font-weight:950;
    }
    .panelsBody{
      padding:10px 12px 12px;
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:10px;
    }
    .card{
      border:1px solid var(--line);
      border-radius:14px;
      background:#0f1a30;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:160px;
    }
    .card h3{
      margin:0;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      font-size:12px;
      font-weight:950;
      color:#fff;
      background:#0a162e;
    }
    .card .content{
      padding:10px 12px;
      overflow:auto;
      font-size:11px;
      color:var(--text);
    }
    .listItem{
      display:flex;
      justify-content:space-between;
      gap:8px;
      padding:6px 0;
      border-bottom:1px dashed rgba(255,255,255,.10);
    }
    .listItem:last-child{ border-bottom:0; }
    .badge{
      display:inline-flex; align-items:center; justify-content:center;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      font-weight:950;
      font-size:10px;
      white-space:nowrap;
    }
    .bDanger{ background: rgba(239,68,68,.18); color:#fecaca; border-color: rgba(239,68,68,.35); }
    .bOk{ background: rgba(34,197,94,.16); color:#bbf7d0; border-color: rgba(34,197,94,.35); }
    .bMuted{ background: rgba(255,255,255,.06); color:#cbd5e1; }
    .mono{ font-variant-numeric: tabular-nums; }

    @media (max-width: 1200px){
      .filters{ grid-template-columns: 1fr 1fr; }
      .kpis{ grid-template-columns: repeat(2,1fr); }
      .panelsBody{ grid-template-columns: 1fr; }
      .gridWrap{ height: calc(100vh - 320px); }
    }
  </style>
</head>

<body>
  <div class="top" id="top">
    <div class="topRow1">
      <div class="titleBlock">
        <div class="title">Painel PMO — Gestão de Capacidade (Folha)</div>
        <div class="subtitle" id="subTitle">Fonte: Google Sheets publicado (CSV). SSOT operacional. Filtros estritos + modos especiais.</div>
      </div>
      <div class="topActions">
        <button class="btn btnSoft" id="btnToggleTop" title="Recolher/Expandir filtros">⇵ Filtros</button>
        <button class="btn btnSoft" id="btnReload">Recarregar dados</button>
      </div>
    </div>

    <div class="filters" id="filters">
      <div class="field">
        <label>Busca (cliente)</label>
        <input id="qClient" placeholder="Ex.: HS MATEUS, ABBR, MEDILAR..." />
      </div>
      <div class="field">
        <label>Filtro por recurso (dropdown)</label>
        <select id="selRes">
          <option value="">Todos</option>
          <option value="DO">DO (Dôra)</option>
          <option value="GE">GE (Geovana)</option>
          <option value="JC">JC (João Custódio)</option>
          <option value="AL">AL (Aline)</option>
        </select>
      </div>
      <div class="field">
        <label>Data início (dd/mm)</label>
        <input id="dStart" placeholder="Ex.: 24/01" />
      </div>
      <div class="field">
        <label>Data fim (dd/mm)</label>
        <input id="dEnd" placeholder="Ex.: 29/04" />
      </div>
      <button class="btn" id="btnClear">Limpar</button>
    </div>

    <div class="chipRow" id="chipRow">
      <button class="chipBtn" data-code="DO" aria-pressed="false" title="DO = Dôra"><span class="dot" style="background:var(--do)"></span>DO</button>
      <button class="chipBtn" data-code="GE" aria-pressed="false" title="GE = Geovana"><span class="dot" style="background:var(--ge)"></span>GE</button>
      <button class="chipBtn" data-code="JC" aria-pressed="false" title="JC = João Custódio"><span class="dot" style="background:var(--jc)"></span>JC</button>
      <button class="chipBtn" data-code="AL" aria-pressed="false" title="AL = Aline"><span class="dot" style="background:var(--al)"></span>AL</button>

      <div class="modeBtns">
        <button class="modeBtn" id="btnCap" aria-pressed="false">Capacidade vs. Demandas</button>
        <button class="modeBtn" id="btnIdle" aria-pressed="false">Taxa de Ociosidade</button>
      </div>
    </div>

    <div class="kpis" id="kpis">
      <div class="kpi"><div class="k">Linhas exibidas</div><div class="v" id="kRows">—</div></div>
      <div class="kpi"><div class="k">Colunas (janela)</div><div class="v" id="kCols">—</div></div>
      <div class="kpi"><div class="k">Células preenchidas (chips)</div><div class="v" id="kFilled">—</div></div>
      <div class="kpi"><div class="k">Hoje</div><div class="v" id="kToday">—</div></div>
    </div>
  </div>

  <div class="gridWrap">
    <div class="panels" id="panels">
      <div class="panelsHeader">
        <div>Exceções operacionais (auto-insights)</div>
        <div class="status" id="insightsStatus">—</div>
      </div>
      <div class="panelsBody">
        <div class="card">
          <h3>1) Colaborador Super Alocado (Conflitos)</h3>
          <div class="content" id="listConflicts"></div>
        </div>
        <div class="card">
          <h3>2) Períodos livres (Colaborador e Time)</h3>
          <div class="content" id="listFree"></div>
        </div>
        <div class="card">
          <h3>3) Saldo de horas por colaborador (mês)</h3>
          <div class="content" id="listHours"></div>
        </div>
      </div>
    </div>

    <div class="gridCard">
      <div class="gridTitle">
        <div>Grade de Alocação</div>
        <div class="status" id="status">Status: carregando…</div>
      </div>

      <!-- scroll vertical -->
      <div class="tableY" id="tableY">
        <!-- scroll horizontal real -->
        <div class="xPane" id="xPane">
          <table id="gridTable">
            <thead>
              <tr id="headDow"></tr>
              <tr id="headDate"></tr>
            </thead>
            <tbody id="body"></tbody>
          </table>
        </div>
      </div>

      <!-- barra horizontal sempre visível (espelho) -->
      <div class="xBar" id="xBar"><div class="xBarInner" id="xBarInner"></div></div>
    </div>
  </div>

<script>
/* ===================== CONFIG ===================== */
const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSgqs7bjsPeaojEQG7buOiixxv7tg1F6jt2wogHKI7O2AvjS-_aq6o7knAO5HgrUd5jZ1iWge4ZgMHM/pub?gid=0&single=true&output=csv";

const RESOURCE_NAMES = { DO:"Dôra", GE:"Geovana", JC:"João Custódio", AL:"Aline" };
const VALID = new Set(["DO","GE","JC","AL"]);
const TURNOS = { M:"MANHÃ", T:"TARDE" };

/* ===================== STATE ===================== */
let rawRows = [];
let dows = [];
let dates = [];
let dateIdxStart = -1;

let dataByClient = []; // [{client, M:{codesByCol}, T:{codesByCol}}] mantendo 2 linhas
let selectedCodes = new Set();
let mode = ""; // "" | "cap" | "idle"

let windowFrom = null;
let windowTo = null;

// conflicts: key -> Set(clients)
let conflictsMap = new Map(); // key: `${code}|${col}|${turnoKey}` => Set(client)
let conflictCols = new Set(); // cols que têm conflito

// idle team: key `${col}|${turnoKey}` true se ninguém alocado naquele período (time)
let idleTeam = new Set();
let idleCols = new Set(); // cols com algum idle (M ou T)

/* ===================== UTILS ===================== */
function setStatus(msg){ document.getElementById("status").textContent = msg; }
function setInsightsStatus(msg){ document.getElementById("insightsStatus").textContent = msg; }

function parseCSV(text){
  const rows=[];
  let row=[], cur="", inQ=false;
  for (let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if (ch === '"' && nx === '"'){ cur+='"'; i++; continue; }
    if (ch === '"'){ inQ=!inQ; continue; }
    if (ch === ',' && !inQ){ row.push(cur); cur=""; continue; }
    if ((ch === '\n' || ch === '\r') && !inQ){
      if (cur.length || row.length){ row.push(cur); rows.push(row); }
      row=[]; cur=""; continue;
    }
    cur+=ch;
  }
  if (cur.length || row.length){ row.push(cur); rows.push(row); }
  return rows.map(r=>r.map(c=>(c??"").trim()));
}

function normalizeDateLabel(s){
  const m=String(s||"").trim().match(/^(\d{1,2})\/(\d{1,2})/);
  if(!m) return String(s||"").trim();
  return `${String(m[1]).padStart(2,"0")}/${String(m[2]).padStart(2,"0")}`;
}

function isWeekend(dow){
  const x=String(dow||"").toUpperCase();
  return x.startsWith("SAB") || x.startsWith("SÁB") || x.startsWith("DOM");
}

function parseCellCodes(cellRaw){
  const raw=String(cellRaw||"").trim();
  if(!raw) return [];
  const normalized = raw.toUpperCase()
    .replace(/\u00A0/g," ")
    .replace(/[\n\r\t]/g," ")
    .replace(/[\/,;|]/g," ")
    .replace(/\s*-\s*/g," ");
  const parts=normalized.split(/\s+/).filter(Boolean);
  const out=[], seen=new Set();
  for(const p of parts){
    const code=p.replace(/[^A-Z]/g,"").slice(0,2);
    if(!VALID.has(code)) continue;
    if(seen.has(code)) continue;
    seen.add(code); out.push(code);
  }
  return out;
}

function ddmmToIndex(ddmm){
  const x = String(ddmm||"").trim();
  const m = x.match(/^(\d{1,2})\/(\d{1,2})$/);
  if(!m) return null;
  const label = `${String(m[1]).padStart(2,"0")}/${String(m[2]).padStart(2,"0")}`;
  const idx = dates.indexOf(label);
  return idx>=0 ? idx : null;
}

function applyWindowFromInputs(){
  const s = document.getElementById("dStart").value.trim();
  const e = document.getElementById("dEnd").value.trim();
  const sIdx = s ? ddmmToIndex(s) : null;
  const eIdx = e ? ddmmToIndex(e) : null;

  windowFrom = (sIdx!==null) ? sIdx : null;
  windowTo = (eIdx!==null) ? eIdx : null;

  if(windowFrom!==null && windowTo!==null && windowFrom>windowTo){
    const tmp = windowFrom; windowFrom = windowTo; windowTo = tmp;
  }
}

function getWindowRange(){
  const from = windowFrom ?? 0;
  const to = windowTo ?? (dates.length-1);
  return {from,to};
}

function cssVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

function chipEl(code, opts={}){
  const v=String(code||"").toUpperCase().trim();
  const sp=document.createElement("span");
  sp.className="chip"+(!v?" empty":"");
  sp.textContent=v || "—";
  if(v && RESOURCE_NAMES[v]) sp.title = `${v} = ${RESOURCE_NAMES[v]}`;

  if(opts.conflict) sp.classList.add("conflict");

  const colors={
    DO:cssVar("--do"), GE:cssVar("--ge"), JC:cssVar("--jc"), AL:cssVar("--al")
  };

  if(v && colors[v] && !opts.conflict){
    sp.style.background = colors[v];
    sp.style.color = "#0b1220";
  }
  if(opts.conflict){
    sp.style.color="#0b1220";
  }
  return sp;
}

function updateKPIs(rowsShown, colsShown, filled){
  document.getElementById("kRows").textContent = String(rowsShown);
  document.getElementById("kCols").textContent = String(colsShown);
  document.getElementById("kFilled").textContent = String(filled);

  const now = new Date();
  const dd = String(now.getDate()).padStart(2,"0");
  const mm = String(now.getMonth()+1).padStart(2,"0");
  document.getElementById("kToday").textContent = `${dd}/${mm}`;
}

/* ===================== BUILD MODEL ===================== */
function buildDataByClient(rows){
  // mantém 2 linhas (M/T) por cliente; não duplica cliente na tabela (rowspan)
  const map = new Map(); // client -> {M:{codesByCol}, T:{codesByCol}}
  let lastClient="";

  for(let r=2;r<rows.length;r++){
    const row=rows[r];
    const first=row.findIndex(c=>c && c!=="");
    if(first<0) continue;

    let client=(row[first]||"").trim();
    let turno=(row[first+1]||"").trim();

    const t=(x)=>String(x||"").toUpperCase().trim();
    const isM = (x)=> (t(x)==="M" || t(x)==="MANHÃ" || t(x)==="MANHA");
    const isT = (x)=> (t(x)==="T" || t(x)==="TARDE");

    // se vier só "M"/"T" na coluna do cliente
    if(isM(client) || isT(client)){
      turno = client;
      client = lastClient || "—";
    }
    if(client && client!=="—") lastClient=client;

    const turnoKey = isM(turno) ? "M" : (isT(turno) ? "T" : "");
    if(!turnoKey) continue;

    const cellsRaw = row.slice(dateIdxStart);
    const codesByCol = cellsRaw.map(c=>parseCellCodes(c));

    if(!map.has(client)){
      map.set(client, { client, M:null, T:null });
    }
    map.get(client)[turnoKey] = { turnoKey, turnoNorm: TURNOS[turnoKey], codesByCol };
  }

  // converter para lista, mantendo ordem de inserção
  return Array.from(map.values()).map(x=>{
    // garantir que existam as duas linhas (mesmo vazias) para manter layout consistente
    if(!x.M) x.M = { turnoKey:"M", turnoNorm:"MANHÃ", codesByCol: Array(dates.length).fill([]) };
    if(!x.T) x.T = { turnoKey:"T", turnoNorm:"TARDE", codesByCol: Array(dates.length).fill([]) };
    return x;
  });
}

/* ===================== COMPUTE CONFLICTS ===================== */
function computeConflicts(){
  conflictsMap.clear();
  conflictCols.clear();

  const {from,to} = getWindowRange();

  // map: code|col|turno -> Set(client)
  for(const c of dataByClient){
    for(const turnoKey of ["M","T"]){
      const row = c[turnoKey];
      for(let col=from; col<=to; col++){
        const codes = row.codesByCol[col] || [];
        for(const code of codes){
          const k = `${code}|${col}|${turnoKey}`;
          if(!conflictsMap.has(k)) conflictsMap.set(k, new Set());
          conflictsMap.get(k).add(c.client);
        }
      }
    }
  }

  // reduzir para somente conflitos (size>1) e registrar colunas
  for(const [k,setClients] of conflictsMap.entries()){
    if(setClients.size > 1){
      const parts = k.split("|");
      const col = Number(parts[1]);
      conflictCols.add(col);
    }
  }
}

/* ===================== COMPUTE IDLE (TEAM) ===================== */
function computeIdle(){
  idleTeam.clear();
  idleCols.clear();

  const {from,to} = getWindowRange();

  // conta alocações do time por col+turno
  const hasAny = new Set(); // `${col}|${turno}`
  for(const c of dataByClient){
    for(const turnoKey of ["M","T"]){
      const row = c[turnoKey];
      for(let col=from; col<=to; col++){
        const codes = row.codesByCol[col] || [];
        if(codes.length>0){
          hasAny.add(`${col}|${turnoKey}`);
        }
      }
    }
  }

  // se não existe no set => idle
  for(let col=from; col<=to; col++){
    for(const turnoKey of ["M","T"]){
      const key = `${col}|${turnoKey}`;
      if(!hasAny.has(key)){
        idleTeam.add(key);
        idleCols.add(col);
      }
    }
  }
}

/* ===================== FILTER LOGIC ===================== */
function getActiveSet(){
  const dd = document.getElementById("selRes").value.trim().toUpperCase();
  const ddSet = dd ? new Set([dd]) : null;

  let active = null;
  if(selectedCodes.size>0) active = new Set(selectedCodes);
  if(ddSet){
    if(active){
      active = new Set([...active].filter(x=>ddSet.has(x)));
    }else{
      active = ddSet;
    }
  }
  return active; // null => sem filtro por colaborador
}

function clientMatches(client){
  const q = document.getElementById("qClient").value.trim().toUpperCase();
  if(!q) return true;
  return String(client||"").toUpperCase().includes(q);
}

function rowHasAnyInWindow(rowCodesByCol, from, to, predicate){
  for(let col=from; col<=to; col++){
    const codes = rowCodesByCol[col] || [];
    if(predicate(codes, col)) return true;
  }
  return false;
}

/* ===================== INSIGHTS ===================== */
function buildInsights(){
  const {from,to} = getWindowRange();

  // 1) Super alocado (conflitos)
  // conflito = code em >1 cliente no mesmo dia e mesmo turno
  // já temos conflictsMap
  const conflictsList = [];
  for(const [k,setClients] of conflictsMap.entries()){
    if(setClients.size <= 1) continue;
    const [code,col,turnoKey] = k.split("|");
    conflictsList.push({
      code,
      name: RESOURCE_NAMES[code] || code,
      date: dates[Number(col)] || "",
      dow: (dows[Number(col)]||"").toUpperCase(),
      turno: TURNOS[turnoKey] || turnoKey,
      clients: Array.from(setClients).sort()
    });
  }
  conflictsList.sort((a,b)=>{
    const da = dates.indexOf(a.date), db = dates.indexOf(b.date);
    if(da!==db) return da-db;
    if(a.turno!==b.turno) return a.turno.localeCompare(b.turno);
    return a.code.localeCompare(b.code);
  });

  // 2) Períodos livres:
  // 2a) time livre (idleTeam) => dia/turno sem ninguém
  const idleTeamList = [];
  for(const key of idleTeam){
    const [col,turnoKey] = key.split("|");
    idleTeamList.push({
      date: dates[Number(col)] || "",
      dow: (dows[Number(col)]||"").toUpperCase(),
      turno: TURNOS[turnoKey] || turnoKey
    });
  }
  idleTeamList.sort((a,b)=> dates.indexOf(a.date)-dates.indexOf(b.date) || a.turno.localeCompare(b.turno));

  // 2b) colaborador livre por período (por dia)
  // regra: se colaborador tem 1 turno alocado e no outro não tem nada -> listar período livre
  const freeByPerson = [];
  for(const code of VALID){
    for(let col=from; col<=to; col++){
      const hasM = hasCodeInAnyClient(code, col, "M");
      const hasT = hasCodeInAnyClient(code, col, "T");
      if(hasM && !hasT){
        freeByPerson.push({ code, name: RESOURCE_NAMES[code], date: dates[col], dow:(dows[col]||"").toUpperCase(), turno:"TARDE" });
      }else if(!hasM && hasT){
        freeByPerson.push({ code, name: RESOURCE_NAMES[code], date: dates[col], dow:(dows[col]||"").toUpperCase(), turno:"MANHÃ" });
      }else if(!hasM && !hasT){
        // totalmente livre no dia (ambos turnos)
        freeByPerson.push({ code, name: RESOURCE_NAMES[code], date: dates[col], dow:(dows[col]||"").toUpperCase(), turno:"DIA INTEIRO" });
      }
    }
  }
  freeByPerson.sort((a,b)=>{
    const da = dates.indexOf(a.date), db = dates.indexOf(b.date);
    if(da!==db) return da-db;
    if(a.code!==b.code) return a.code.localeCompare(b.code);
    return a.turno.localeCompare(b.turno);
  });

  // 3) Saldo de horas por colaborador (mês)
  // planned = dias úteis do mês * 8h
  // allocated = ocorrências do code (chips) no mês * 4h (cada turno)
  const monthStats = computeHoursByMonth(from,to);

  // render
  renderConflictsList(conflictsList);
  renderFreeList(idleTeamList, freeByPerson);
  renderHoursList(monthStats);

  setInsightsStatus(`Conflitos: ${conflictsList.length} • Ociosidade time: ${idleTeamList.length} • Livres colaborador: ${freeByPerson.length}`);
}

function hasCodeInAnyClient(code, col, turnoKey){
  for(const c of dataByClient){
    const row = c[turnoKey];
    const codes = row.codesByCol[col] || [];
    if(codes.includes(code)) return true;
  }
  return false;
}

function computeHoursByMonth(from,to){
  // map month "MM" -> {businessDays:Set(dateLabel), allocCountByCode:{DO:n,...}}
  const m = new Map();

  function monthOf(label){
    const mm = String(label||"").split("/")[1];
    return mm || "??";
  }
  function isBusiness(col){
    return !isWeekend(dows[col]);
  }

  for(let col=from; col<=to; col++){
    const month = monthOf(dates[col]);
    if(!m.has(month)){
      m.set(month, { month, businessDays:new Set(), allocCount: {DO:0,GE:0,JC:0,AL:0} });
    }
    const entry = m.get(month);
    if(isBusiness(col)) entry.businessDays.add(dates[col]);

    // contar alocações (chips) do code (cada ocorrência=1 período=4h)
    for(const c of dataByClient){
      for(const turnoKey of ["M","T"]){
        const codes = (c[turnoKey].codesByCol[col] || []);
        for(const code of codes){
          if(entry.allocCount[code] !== undefined){
            entry.allocCount[code] += 1;
          }
        }
      }
    }
  }

  const out = [];
  for(const entry of m.values()){
    const businessDays = entry.businessDays.size;
    const plannedPerPerson = businessDays * 8; // horas
    const row = { month: entry.month, businessDays, plannedPerPerson, items: [] };
    for(const code of ["DO","GE","JC","AL"]){
      const allocatedHours = entry.allocCount[code] * 4;
      const saldo = plannedPerPerson - allocatedHours;
      row.items.push({ code, name: RESOURCE_NAMES[code], planned: plannedPerPerson, allocated: allocatedHours, saldo });
    }
    out.push(row);
  }
  out.sort((a,b)=> Number(a.month)-Number(b.month));
  return out;
}

function renderConflictsList(items){
  const el = document.getElementById("listConflicts");
  if(!items.length){
    el.innerHTML = `<div class="badge bOk">Sem conflitos na janela</div>`;
    return;
  }
  el.innerHTML = items.map(x=>{
    const clients = x.clients.join(", ");
    return `
      <div class="listItem">
        <div>
          <div><span class="badge bDanger">${x.code}</span> <b>${x.name}</b> • <span class="mono">${x.dow} ${x.date}</span> • <b>${x.turno}</b></div>
          <div style="color:var(--muted); margin-top:2px">Clientes: ${clients}</div>
        </div>
        <div class="badge bDanger">Super</div>
      </div>
    `;
  }).join("");
}

function renderFreeList(idleTeamList, freeByPerson){
  const el = document.getElementById("listFree");
  const block1 = idleTeamList.length
    ? `<div class="badge bOk">Time 100% ocioso (período)</div>` +
      idleTeamList.slice(0,80).map(x=>`
        <div class="listItem">
          <div><b>${x.turno}</b> • <span class="mono">${x.dow} ${x.date}</span></div>
          <div class="badge bOk">Livre</div>
        </div>
      `).join("") +
      (idleTeamList.length>80? `<div style="margin-top:8px;color:var(--muted)">+ ${idleTeamList.length-80} itens…</div>`:"")
    : `<div class="badge bMuted">Sem períodos 100% livres do time na janela</div>`;

  const block2 = freeByPerson.length
    ? `<div style="margin-top:12px" class="badge bMuted">Livre por colaborador (turno)</div>` +
      freeByPerson.slice(0,80).map(x=>`
        <div class="listItem">
          <div><span class="badge bMuted">${x.code}</span> <b>${x.name}</b> • <span class="mono">${x.dow} ${x.date}</span> • ${x.turno}</div>
          <div class="badge bOk">Gap</div>
        </div>
      `).join("") +
      (freeByPerson.length>80? `<div style="margin-top:8px;color:var(--muted)">+ ${freeByPerson.length-80} itens…</div>`:"")
    : `<div style="margin-top:12px" class="badge bMuted">Nenhum gap por colaborador</div>`;

  el.innerHTML = block1 + block2;
}

function renderHoursList(monthStats){
  const el = document.getElementById("listHours");
  if(!monthStats.length){
    el.innerHTML = `<div class="badge bMuted">Sem dados</div>`;
    return;
  }

  let html = "";
  for(const m of monthStats){
    html += `<div class="badge bMuted">Mês ${m.month} • Dias úteis: ${m.businessDays} • Previsto/pessoa: ${m.plannedPerPerson}h</div>`;
    html += `<div style="margin-top:8px"></div>`;
    for(const it of m.items){
      const cls = it.saldo < 0 ? "bDanger" : "bOk";
      html += `
        <div class="listItem">
          <div><span class="badge bMuted">${it.code}</span> <b>${it.name}</b></div>
          <div class="mono">
            <span class="badge bMuted">Alocado ${it.allocated}h</span>
            <span class="badge ${cls}">Saldo ${it.saldo}h</span>
          </div>
        </div>
      `;
    }
    html += `<div style="height:10px"></div>`;
  }
  el.innerHTML = html;
}

/* ===================== RENDER ===================== */
function render(){
  applyWindowFromInputs();
  const {from,to} = getWindowRange();

  // recalcular modos
  if(mode==="cap"){
    computeConflicts();
  }else{
    conflictsMap.clear();
    conflictCols.clear();
  }

  if(mode==="idle"){
    computeIdle();
  }else{
    idleTeam.clear();
    idleCols.clear();
  }

  // header
  const headDow = document.getElementById("headDow");
  const headDate = document.getElementById("headDate");
  headDow.innerHTML=""; headDate.innerHTML="";

  const thClient=document.createElement("th");
  thClient.className="thClient";
  thClient.textContent="Cliente";
  thClient.rowSpan=2;

  const thTurno=document.createElement("th");
  thTurno.className="thTurno";
  thTurno.textContent="Turno";
  thTurno.rowSpan=2;

  headDow.appendChild(thClient);
  headDow.appendChild(thTurno);

  // decidir colunas visíveis
  const colVisible = new Array(dates.length).fill(true);
  for(let col=0; col<dates.length; col++){
    if(col<from || col>to) colVisible[col]=false;
  }
  if(mode==="cap"){
    // filtrar para colunas com conflitos na janela
    for(let col=from; col<=to; col++){
      if(!conflictCols.has(col)) colVisible[col]=false;
    }
  }
  if(mode==="idle"){
    // filtrar para colunas que têm algum período do time 100% livre
    for(let col=from; col<=to; col++){
      if(!idleCols.has(col)) colVisible[col]=false;
    }
  }

  // DOW
  for(let col=0; col<dates.length; col++){
    const th=document.createElement("th");
    th.textContent=(dows[col]||"").toUpperCase();
    th.style.width=th.style.minWidth=th.style.maxWidth = cssVar("--wDate") || "64px";

    if(!colVisible[col]) th.classList.add("colHidden");
    if(isWeekend(dows[col])) th.classList.add("weekend");

    if(mode==="idle" && (idleTeam.has(`${col}|M`) || idleTeam.has(`${col}|T`))){
      th.classList.add("freeHdr");
    }
    if(mode==="cap" && conflictCols.has(col)){
      th.classList.add("confHdr");
    }

    headDow.appendChild(th);
  }

  // DATE
  for(let col=0; col<dates.length; col++){
    const th=document.createElement("th");
    th.textContent=dates[col];
    th.style.width=th.style.minWidth=th.style.maxWidth = cssVar("--wDate") || "64px";

    if(!colVisible[col]) th.classList.add("colHidden");
    if(isWeekend(dows[col])) th.classList.add("weekend");

    if(mode==="idle" && (idleTeam.has(`${col}|M`) || idleTeam.has(`${col}|T`))){
      th.classList.add("freeHdr");
    }
    if(mode==="cap" && conflictCols.has(col)){
      th.classList.add("confHdr");
    }

    headDate.appendChild(th);
  }

  // body
  const activeSet = getActiveSet();
  const tbody = document.getElementById("body");
  tbody.innerHTML="";

  let rowsShown = 0;
  let filled = 0;

  // decidir se cliente passa filtros
  for(const c of dataByClient){
    if(!clientMatches(c.client)) continue;

    // linhas por turno (M/T)
    // row visible se tem algo relevante (pela seleção/mode) dentro da janela e colunas visíveis
    const rowM = c.M;
    const rowT = c.T;

    const mVisible = rowPasses(rowM, c.client, "M", activeSet, from, to, colVisible);
    const tVisible = rowPasses(rowT, c.client, "T", activeSet, from, to, colVisible);

    // se nenhuma aparece, pula cliente inteiro
    if(!mVisible && !tVisible) continue;

    // criar duas linhas; cliente com rowspan=2 (mesmo se uma linha for "invisível", a gente ainda renderiza com células vazias para manter alinhamento)
    // mas, para evitar "linha desalinhada", manter sempre as duas linhas quando cliente entra
    const trM = document.createElement("tr");
    trM.className = "rowM";

    const tdClient = document.createElement("td");
    tdClient.className = "tdClient";
    tdClient.rowSpan = 2;
    const cc = document.createElement("div");
    cc.className = "clientCell";
    cc.textContent = c.client;
    tdClient.appendChild(cc);

    const tdTurnoM = document.createElement("td");
    tdTurnoM.className = "tdTurno";
    tdTurnoM.textContent = "MANHÃ";

    trM.appendChild(tdClient);
    trM.appendChild(tdTurnoM);

    // células M
    for(let col=0; col<dates.length; col++){
      const td = document.createElement("td");
      td.style.width=td.style.minWidth=td.style.maxWidth = cssVar("--wDate") || "64px";
      if(!colVisible[col]) td.classList.add("colHidden");
      if(isWeekend(dows[col])) td.classList.add("weekend");

      if(mode==="idle" && idleTeam.has(`${col}|M`)){
        td.classList.add("freeCell");
      }

      const codesAll = (rowM.codesByCol[col] || []);
      filled += codesAll.length;

      const box = document.createElement("div");
      box.className = "cellChips";

      if(!mVisible){
        // cliente entra mas linha não passa (para manter alinhamento); mostra vazio
        box.appendChild(chipEl(""));
      }else{
        if(mode==="cap"){
          // mostrar somente conflitos
          const out = [];
          for(const code of codesAll){
            const key = `${code}|${col}|M`;
            const setClients = conflictsMap.get(key);
            if(setClients && setClients.size>1) out.push(code);
          }
          if(out.length===0){
            box.appendChild(chipEl(""));
          }else{
            for(const code of out){
              box.appendChild(chipEl(code, { conflict:true }));
            }
          }
        }else{
          // filtro estrito
          let codes = codesAll;
          if(activeSet) codes = codesAll.filter(x=>activeSet.has(x));
          if(codes.length===0){
            box.appendChild(chipEl(""));
          }else{
            for(const code of codes) box.appendChild(chipEl(code));
          }
        }
      }

      td.appendChild(box);
      trM.appendChild(td);
    }

    const trT = document.createElement("tr");
    trT.className = "rowT";

    const tdTurnoT = document.createElement("td");
    tdTurnoT.className = "tdTurno";
    tdTurnoT.textContent = "TARDE";
    trT.appendChild(tdTurnoT);

    // células T
    for(let col=0; col<dates.length; col++){
      const td = document.createElement("td");
      td.style.width=td.style.minWidth=td.style.maxWidth = cssVar("--wDate") || "64px";
      if(!colVisible[col]) td.classList.add("colHidden");
      if(isWeekend(dows[col])) td.classList.add("weekend");

      if(mode==="idle" && idleTeam.has(`${col}|T`)){
        td.classList.add("freeCell");
      }

      const codesAll = (rowT.codesByCol[col] || []);
      filled += codesAll.length;

      const box = document.createElement("div");
      box.className = "cellChips";

      if(!tVisible){
        box.appendChild(chipEl(""));
      }else{
        if(mode==="cap"){
          const out = [];
          for(const code of codesAll){
            const key = `${code}|${col}|T`;
            const setClients = conflictsMap.get(key);
            if(setClients && setClients.size>1) out.push(code);
          }
          if(out.length===0){
            box.appendChild(chipEl(""));
          }else{
            for(const code of out){
              box.appendChild(chipEl(code, { conflict:true }));
            }
          }
        }else{
          let codes = codesAll;
          if(activeSet) codes = codesAll.filter(x=>activeSet.has(x));
          if(codes.length===0){
            box.appendChild(chipEl(""));
          }else{
            for(const code of codes) box.appendChild(chipEl(code));
          }
        }
      }

      td.appendChild(box);
      trT.appendChild(td);
    }

    // anexar
    tbody.appendChild(trM);
    tbody.appendChild(trT);

    // contagem de linhas exibidas = 2 por cliente visível
    rowsShown += 2;
  }

  // KPIs
  const colsShown = colVisible.filter(Boolean).length;
  updateKPIs(rowsShown, colsShown, filled);

  // status
  if(mode==="cap"){
    let conflictsCount = 0;
    for(const [k,setClients] of conflictsMap.entries()){
      if(setClients.size>1) conflictsCount++;
    }
    setStatus(`Status: carregado • Modo: Capacidade vs. Demandas • Conflitos: ${conflictsCount}`);
  }else if(mode==="idle"){
    setStatus(`Status: carregado • Modo: Taxa de Ociosidade • Períodos 100% livres (time): ${idleTeam.size}`);
  }else{
    setStatus(`Status: carregado`);
  }

  // insights (reusa conflitos/idle conforme modo)
  // sempre computar ambos para painel completo
  computeConflicts();
  computeIdle();
  buildInsights();

  // sincronizar barra horizontal sempre visível
  syncXBar();
}

/* decide se linha passa filtros/mode */
function rowPasses(row, client, turnoKey, activeSet, from, to, colVisible){
  // se modo cap: precisa ter algum conflito nessa linha (col visível)
  if(mode==="cap"){
    for(let col=from; col<=to; col++){
      if(!colVisible[col]) continue;
      const codes = row.codesByCol[col] || [];
      for(const code of codes){
        const key = `${code}|${col}|${turnoKey}`;
        const setClients = conflictsMap.get(key);
        if(setClients && setClients.size>1) return true;
      }
    }
    return false;
  }

  // se modo idle: precisa ter pelo menos uma coluna visível com idle do time nesse turno
  if(mode==="idle"){
    for(let col=from; col<=to; col++){
      if(!colVisible[col]) continue;
      if(idleTeam.has(`${col}|${turnoKey}`)) return true;
    }
    return false;
  }

  // modo normal: se há filtro por colaborador, linha precisa ter algum chip desse set na janela
  if(activeSet){
    for(let col=from; col<=to; col++){
      if(!colVisible[col]) continue;
      const codes = row.codesByCol[col] || [];
      for(const code of codes){
        if(activeSet.has(code)) return true;
      }
    }
    return false;
  }

  // sem filtros: sempre passa
  return true;
}

/* ===================== SCROLLBAR ALWAYS VISIBLE ===================== */
function syncXBar(){
  const xPane = document.getElementById("xPane");
  const xBar = document.getElementById("xBar");
  const xBarInner = document.getElementById("xBarInner");

  // largura real do conteúdo (scrollWidth)
  const w = xPane.scrollWidth;
  xBarInner.style.width = w + "px";

  // se o conteúdo for menor que viewport, ainda mantém coerência
  // sync scrollLeft
  if(Math.abs(xBar.scrollLeft - xPane.scrollLeft) > 1){
    xBar.scrollLeft = xPane.scrollLeft;
  }
}

function wireScrollSync(){
  const xPane = document.getElementById("xPane");
  const xBar = document.getElementById("xBar");

  let lock=false;
  xPane.addEventListener("scroll", ()=>{
    if(lock) return;
    lock=true;
    xBar.scrollLeft = xPane.scrollLeft;
    lock=false;
  }, {passive:true});

  xBar.addEventListener("scroll", ()=>{
    if(lock) return;
    lock=true;
    xPane.scrollLeft = xBar.scrollLeft;
    lock=false;
  }, {passive:true});

  window.addEventListener("resize", ()=>syncXBar());
}

/* ===================== LOAD ===================== */
async function load(){
  setStatus("Status: carregando…");
  try{
    const res = await fetch(CSV_URL, {cache:"no-store"});
    if(!res.ok) throw new Error("Falha ao buscar CSV");
    const csv = await res.text();

    rawRows = parseCSV(csv).filter(r=>r.some(c=>c && c!==""));
    if(rawRows.length<3){
      setStatus("Status: CSV vazio/curto");
      return;
    }

    const dowRow = rawRows[0];
    const dateRow = rawRows[1];

    dateIdxStart = dateRow.findIndex(c=>/^\d{1,2}\/\d{1,2}/.test(c));
    if(dateIdxStart<0){
      setStatus("Status: não encontrei linha de datas");
      return;
    }

    dows = dowRow.slice(dateIdxStart);
    dates = dateRow.slice(dateIdxStart).map(normalizeDateLabel);

    dataByClient = buildDataByClient(rawRows);

    render();
  }catch(e){
    console.error(e);
    setStatus("Status: erro ao carregar");
  }
}

/* ===================== UI ===================== */
function wireUI(){
  // chips seleção estrita (multi)
  document.querySelectorAll(".chipBtn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const code = btn.getAttribute("data-code");
      const on = btn.getAttribute("aria-pressed")==="true";
      btn.setAttribute("aria-pressed", on ? "false":"true");
      if(on) selectedCodes.delete(code);
      else selectedCodes.add(code);

      // se estiver em modo cap/idle, mantém
      render();
    });
  });

  // modos
  const btnCap = document.getElementById("btnCap");
  const btnIdle = document.getElementById("btnIdle");

  btnCap.addEventListener("click", ()=>{
    const on = btnCap.getAttribute("aria-pressed")==="true";
    btnCap.setAttribute("aria-pressed", on?"false":"true");
    btnIdle.setAttribute("aria-pressed","false");
    mode = on ? "" : "cap";
    render();
  });

  btnIdle.addEventListener("click", ()=>{
    const on = btnIdle.getAttribute("aria-pressed")==="true";
    btnIdle.setAttribute("aria-pressed", on?"false":"true");
    btnCap.setAttribute("aria-pressed","false");
    mode = on ? "" : "idle";
    render();
  });

  // inputs
  ["qClient","selRes","dStart","dEnd"].forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener("input", ()=>render());
    el.addEventListener("change", ()=>render());
  });

  // limpar
  document.getElementById("btnClear").addEventListener("click", ()=>{
    selectedCodes.clear();
    document.querySelectorAll(".chipBtn").forEach(b=>b.setAttribute("aria-pressed","false"));
    document.getElementById("qClient").value="";
    document.getElementById("selRes").value="";
    document.getElementById("dStart").value="";
    document.getElementById("dEnd").value="";
    mode="";
    document.getElementById("btnCap").setAttribute("aria-pressed","false");
    document.getElementById("btnIdle").setAttribute("aria-pressed","false");
    render();
  });

  // reload
  document.getElementById("btnReload").addEventListener("click", ()=>load());

  // collapse
  document.getElementById("btnToggleTop").addEventListener("click", ()=>{
    const top = document.getElementById("top");
    top.classList.toggle("collapsed");
    // ajusta altura da grid
    // (o CSS usa calc fixo; funciona bem. mas forçar repaint ajuda)
    setTimeout(()=>syncXBar(), 50);
  });
}

/* ===================== BOOT ===================== */
wireScrollSync();
wireUI();
load();
</script>
</body>
</html>
