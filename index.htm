/* ===================== IDLE TEAM (DIAS ÚTEIS) ===================== */
function computeIdle(){
  idleTeam.clear();
  idleCols.clear();
  const {from,to} = getWindowRange();

  const hasAny = new Set(); // `${col}|${turno}`

  // Marca onde existe qualquer alocação (somente dias úteis)
  for(const c of dataByClient){
    for(const turnoKey of ["M","T"]){
      const row = c[turnoKey];
      for(let col=from; col<=to; col++){
        if (isWeekend(dows[col])) continue; // <-- IGNORA sábado/domingo
        const codes = row.codesByCol[col] || [];
        if(codes.length > 0){
          hasAny.add(`${col}|${turnoKey}`);
        }
      }
    }
  }

  // Considera o time 100% ocioso apenas em dias úteis
  for(let col=from; col<=to; col++){
    if (isWeekend(dows[col])) continue; // <-- IGNORA sábado/domingo
    for(const turnoKey of ["M","T"]){
      const key = `${col}|${turnoKey}`;
      if(!hasAny.has(key)){
        idleTeam.add(key);
        idleCols.add(col);
      }
    }
  }
}

/* ===================== INSIGHTS (AJUSTE LIVRES POR PESSOA: DIAS ÚTEIS) ===================== */
/* Dentro de buildInsights(), SUBSTITUA apenas o bloco "// livre por pessoa" pelo bloco abaixo */

  // livre por pessoa (somente dias úteis)
  const freeByPerson = [];
  for(const code of VALID){
    for(let col=from; col<=to; col++){
      if (isWeekend(dows[col])) continue; // <-- IGNORA sábado/domingo

      const hasM = hasCodeInAnyClient(code, col, "M");
      const hasT = hasCodeInAnyClient(code, col, "T");

      if(hasM && !hasT){
        freeByPerson.push({ code, name: RESOURCE_NAMES[code], date: dates[col], dow:(dows[col]||"").toUpperCase(), turno:"TARDE" });
      }else if(!hasM && hasT){
        freeByPerson.push({ code, name: RESOURCE_NAMES[code], date: dates[col], dow:(dows[col]||"").toUpperCase(), turno:"MANHÃ" });
      }else if(!hasM && !hasT){
        freeByPerson.push({ code, name: RESOURCE_NAMES[code], date: dates[col], dow:(dows[col]||"").toUpperCase(), turno:"DIA INTEIRO" });
      }
    }
  }
  freeByPerson.sort((a,b)=>{
    const da = dates.indexOf(a.date), db = dates.indexOf(b.date);
    if(da!==db) return da-db;
    if(a.code!==b.code) return a.code.localeCompare(b.code);
    return a.turno.localeCompare(b.turno);
  });
